# dom-diff

## 1. 整体策略
### 1.1. 递归算法
1. 先来看一下，dom-diff使用了怎样的递归策略。
![./images/DFS-compare.png](./images/DFS-compare.png)
图中的 1,2,3,...,10,11 代表了递归检索的顺序，并使用了`先序`遍历 (详见3)
>当分析到`源码`的递归思路时，可能会感到困惑，到底是`二叉树`，还是`多叉树`.<br>
>结论是`多叉树`，虽然比较函数传递了`老节点`和`新节点`，但是分别对`老节点`和`新节点`进行了递归.<br>
>并且把**每一层**`老节点`和`新节点`**同时递归**，确保他们递归到的是**同一层**.
2. `老节点` <==> `新节点`
![./images/DFS-react.png](./images/DFS-react.png)
图中假设了`OA`和`NA`类型相同，`OC`和`NC`类型相同
3. 深度优先遍历:<br>
>先序 —> 父节点,左子树,右子树<br>
>中序 —> 左子树,父节点,右子树<br>
>后序 -> 左子树,右子树,父节点
----
*** **结论：**
* dom-diff是`多叉树深度遍历`，但不是简单的单颗树遍历.
* dom-diff深度遍历规则是，如果类型相同，老节点遍历到`第n层`，新节点也一定同时遍历到`第n层`.
* dom-diff采用的深度优先遍历，属于先序遍历.
----
### 1.2. 比对算法
### 1.3. 移动和剔除
* dom-diff利用diffQueue进行整体移动和剔除，将parentNode、操作方式(移动/剔除)、索引、dom等信息，作为对象放入diffQueue
* 每递归到一层，全局变量updateDepth++，每执行完一层，updateDepth--，当执行到最末端叶子层，此时updateDepth最大，当所有层执行完毕，updateDepth还原为0，此时循环触发diffQueue中的操作
* 由于深度优先，最末端的叶子操作，在diffQueue中的位置，总是比叶子所属的父节点靠前，这样保证了总是先执行叶子层操作，再执行该叶子层对应的父节点层操作，就不会出现“先删除了父节点，叶子节点操作时报错”

## 2. 代码实现
* **在解读源代码实现时，对照`1.整体策略`的分析便于理解**

